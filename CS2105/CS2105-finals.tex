\documentclass[10pt,landscape,a4paper]{article}
%\usepackage[utf8]{inputenc}
%\usepackage[ngerman]{babel}
\usepackage[normalem]{ulem}
\usepackage{tikz}
\usetikzlibrary{shapes,positioning,arrows,fit,calc,graphs,graphs.standard}
\usepackage[nosf]{kpfonts}
\usepackage[t1]{sourcesanspro}
%\usepackage[lf]{MyriadPro}
%\usepackage[lf,minionint]{MinionPro}
\usepackage{multicol}
\usepackage{wrapfig}
\usepackage[top=0mm,bottom=1mm,left=0mm,right=1mm]{geometry}
\usepackage[framemethod=tikz]{mdframed}
\usepackage{microtype}
\usepackage{physics}
\usepackage{tabularx}
\usepackage{hhline}
\usepackage{makecell}
\usepackage{mathtools}

\usepackage{listings}

\DeclarePairedDelimiter{\ceil}{\lceil}{\rceil}

\newcommand\codeblue[1]{\textcolor{blue}{\code{#1}}}

\usepackage{lastpage}
\usepackage{datetime}
\yyyymmdddate
\renewcommand{\dateseparator}{-}
\let\bar\overline

\definecolor{myblue}{cmyk}{1,.72,0,.38}

\def\firstcircle{(0,0) circle (1.5cm)}
\def\secondcircle{(0:2cm) circle (1.5cm)}

\colorlet{circle edge}{myblue}
\colorlet{circle area}{myblue!5}

\tikzset{filled/.style={fill=circle area, draw=circle edge, thick},
  outline/.style={draw=circle edge, thick}}

\pgfdeclarelayer{background}
\pgfsetlayers{background,main}

%\everymath\expandafter{\the\everymath \color{myblue}}
%\everydisplay\expandafter{\the\everydisplay \color{myblue}}


\renewcommand{\baselinestretch}{.8}
\pagestyle{empty}

\global\mdfdefinestyle{header}{%
  linecolor=gray,linewidth=1pt,%
  leftmargin=0mm,rightmargin=0mm,skipbelow=0mm,skipabove=0mm,
}

\newcommand{\header}{
  \begin{mdframed}[style=header]
    \footnotesize
    \sffamily
    CS2105 Finals Cheatsheet v1.0 (\today)\\
    by~Julius Putra Tanu Setiaji,~page~\thepage~of~\pageref{LastPage}
  \end{mdframed}
}

\let\counterwithout\relax
\let\counterwithin\relax
\usepackage{chngcntr}

\usepackage{verbatim}

\usepackage{etoolbox}
\makeatletter
\preto{\@verbatim}{\topsep=0pt \partopsep=0pt }
\makeatother

\counterwithin*{equation}{section}
\counterwithin*{equation}{subsection}
\usepackage{enumitem}
\newlist{legal}{enumerate}{10}
\setlist[legal]{label*=\arabic*.,leftmargin=2.5mm}
\setlist[itemize]{leftmargin=3mm}
\setlist[enumerate]{leftmargin=3.5mm}
\setlist{nosep}
\usepackage{minted}

\def\code#1{\texttt{#1}}

\newenvironment{descitemize} % a mixture of description and itemize
{\begin{description}[leftmargin=*,before=\let\makelabel\descitemlabel]}
    {\end{description}}

\newcommand{\descitemlabel}[1]{%
  \textbullet\ \textbf{#1}%
}
\makeatletter



\renewcommand{\section}{\@startsection{section}{1}{0mm}%
  {.2ex}%
  {.2ex}%x
  {\color{myblue}\sffamily\small\bfseries}}
\renewcommand{\subsection}{\@startsection{subsection}{1}{0mm}%
  {.2ex}%
  {.2ex}%x
  {\sffamily\bfseries}}
\renewcommand{\subsubsection}{\@startsection{subsubsection}{1}{0mm}%
  {.2ex}%
  {.2ex}%x
  {\rmfamily\bfseries}}



\def\multi@column@out{%
  \ifnum\outputpenalty <-\@M
  \speci@ls \else
  \ifvoid\colbreak@box\else
    \mult@info\@ne{Re-adding forced
      break(s) for splitting}%
    \setbox\@cclv\vbox{%
      \unvbox\colbreak@box
      \penalty-\@Mv\unvbox\@cclv}%
  \fi
  \splittopskip\topskip
  \splitmaxdepth\maxdepth
  \dimen@\@colroom
  \divide\skip\footins\col@number
  \ifvoid\footins \else
    \leave@mult@footins
  \fi
  \let\ifshr@kingsaved\ifshr@king
  \ifvbox \@kludgeins
    \advance \dimen@ -\ht\@kludgeins
    \ifdim \wd\@kludgeins>\z@
      \shr@nkingtrue
    \fi
  \fi
  \process@cols\mult@gfirstbox{%
    %%%%% START CHANGE
    \ifnum\count@=\numexpr\mult@rightbox+2\relax
      \setbox\count@\vsplit\@cclv to \dimexpr \dimen@-1cm\relax
      \setbox\count@\vbox to \dimen@{\vbox to 1cm{\header}\unvbox\count@\vss}%
    \else
      \setbox\count@\vsplit\@cclv to \dimen@
    \fi
    %%%%% END CHANGE
    \set@keptmarks
    \setbox\count@
    \vbox to\dimen@
    {\unvbox\count@
      \remove@discardable@items
      \ifshr@nking\vfill\fi}%
  }%
  \setbox\mult@rightbox
  \vsplit\@cclv to\dimen@
  \set@keptmarks
  \setbox\mult@rightbox\vbox to\dimen@
  {\unvbox\mult@rightbox
    \remove@discardable@items
    \ifshr@nking\vfill\fi}%
  \let\ifshr@king\ifshr@kingsaved
  \ifvoid\@cclv \else
    \unvbox\@cclv
    \ifnum\outputpenalty=\@M
    \else
      \penalty\outputpenalty
    \fi
    \ifvoid\footins\else
      \PackageWarning{multicol}%
      {I moved some lines to
        the next page.\MessageBreak
        Footnotes on page
        \thepage\space might be wrong}%
    \fi
    \ifnum \c@tracingmulticols>\thr@@
      \hrule\allowbreak \fi
  \fi
  \ifx\@empty\kept@firstmark
    \let\firstmark\kept@topmark
    \let\botmark\kept@topmark
  \else
    \let\firstmark\kept@firstmark
    \let\botmark\kept@botmark
  \fi
  \let\topmark\kept@topmark
  \mult@info\tw@
  {Use kept top mark:\MessageBreak
    \meaning\kept@topmark
    \MessageBreak
    Use kept first mark:\MessageBreak
    \meaning\kept@firstmark
    \MessageBreak
    Use kept bot mark:\MessageBreak
    \meaning\kept@botmark
    \MessageBreak
    Produce first mark:\MessageBreak
    \meaning\firstmark
    \MessageBreak
    Produce bot mark:\MessageBreak
    \meaning\botmark
    \@gobbletwo}%
  \setbox\@cclv\vbox{\unvbox\partial@page
    \page@sofar}%
  \@makecol\@outputpage
  \global\let\kept@topmark\botmark
  \global\let\kept@firstmark\@empty
  \global\let\kept@botmark\@empty
  \mult@info\tw@
  {(Re)Init top mark:\MessageBreak
    \meaning\kept@topmark
    \@gobbletwo}%
  \global\@colroom\@colht
  \global \@mparbottom \z@
  \process@deferreds
  \@whilesw\if@fcolmade\fi{\@outputpage
      \global\@colroom\@colht
      \process@deferreds}%
    \mult@info\@ne
    {Colroom:\MessageBreak
      \the\@colht\space
      after float space removed
      = \the\@colroom \@gobble}%
    \set@mult@vsize \global
  \fi}
\global\let\tikz@ensure@dollar@catcode=\relax

\def\mathcolor#1#{\@mathcolor{#1}}
\def\@mathcolor#1#2#3{%
  \protect\leavevmode
  \begingroup
  \color#1{#2}#3%
  \endgroup
}

\makeatother
\setlength{\parindent}{0pt}

\setminted{tabsize=2, breaklines}
% Remove belowskip of minted
\setlength\partopsep{-\topsep}

\setlength\columnsep{1.5pt}
\setlength\columnseprule{0.1pt}

\begin{document}
\setlength{\abovedisplayskip}{0pt}
\setlength{\belowdisplayskip}{0pt}


\scriptsize
\begin{multicols*}{4}
  \raggedcolumns
  \section{Computer Networks and the Internet}
  \subsection{What is the Internet}
  \subsection{Network Edge}
  \subsection{Network Core}
  \subsubsection{Circuit switching}
  Dedicated circuit per call
  \begin{itemize}
    \item call setup required
    \item circuit-like (guaranteed) performance
    \item circuit segment idle if not used (no sharing)
  \end{itemize}
  \subsubsection{Packet Switching}
  Data sent through the net in discrete chunks
  \begin{itemize}
    \item \textbf{Store-and-forward}: entire packet must arrive at a router before it can be transmitted to the next link.
    \item \textbf{Addressing}: each packet needs to carry source and destination information
    \item Users share network resources
    \item Resources are used on demand
    \item Excessive congestion is possible
  \end{itemize}

  \subsection{Delay, Loss and Throughput in Networks}
  End-to-end packet delay consisting of 4 sources
  \subsubsection{4 Sources of Packet Delay}
  \begin{itemize}
    \item Nodal Processing ($d_{proc}$): check bit errors, determine output link, typically $<$ msec
    \item Queueing ($d_{queue}$): waiting in queue for transmission, depends on congestion level of router
    \item Transmission ($d_{trans} = \frac{L}{R}$): L = packet length (bits), R = link bandwidth (bps)
    \item Propagation ($d_{prop} = \frac{d}{s}$): d = length of physical link, s = propagation speed in medium ($2\times 10^8m/sec$)
  \end{itemize}
  \subsubsection{Throughput}
  \begin{itemize}
    \item How many bits can be transmitted per unit time
    \item Measured for end-to-end communication. Compare with link capacity (bandwidth) only for specific link
  \end{itemize}
  \subsubsection{Units}
  \begin{itemize}
    \item 1 byte = 8 bits
    \item (-) Prefixes: milli, micro, nano, pico, femto, atto, zepto, yocto
    \item (+) Prefixes: kilo, mega, giga, tera, peta, exa, zetta, yotta
  \end{itemize}

  \subsection{Protocol Layers and Service Models}
  \subsubsection{5 Layers}
  \begin{itemize}
    \item \textbf{Application}: supporting network applications, e.g. FTP, SMTP, HTTP
    \item \textbf{Transport}: process-to-process data transfer, e.g. TCP, UDP
    \item \textbf{Network}: routing of datagrams from source to destination, e.g. IP, routing protocols
    \item \textbf{Link}: Data transfer between neighbouring network elements, e.g. Ethernet, 802.11, PPP
    \item \textbf{Physical}: ``on the wire''
  \end{itemize}

  \subsubsection{ISO/OSI Reference Model}
  Theoretical only, 2 additional layers between \textbf{Application} and \textbf{Transport}: \textbf{Presentation} (allow applications to interpret meaning of data, e.g. encryption, compression, machine-specific convention) and \textbf{Session} (synchronisation, checkpointing, recovery of data exchange)

  \section{Application Layer}
  \subsection{Principles of Network Applications}
  \subsubsection{Client-Server}
  \begin{itemize}
    \item \textbf{Server}: waits for incoming requests, provides requested service to client, data centers for scaling
    \item \textbf{Client}: initiates contact with server, typically requests service from server, For web, client is usually implemented in browser
  \end{itemize}
  \subsubsection{Peer-to-Peer (P2P)}
  \begin{itemize}
    \item No always-on server
    \item Arbitrary end systems directly communicate.
    \item Peers request service from other peers, provide service in return to other peers
    \item \textbf{Self-scalability}: new peers bring new service capacity, as well as new service demands
    \item Peers are intermittently connected and change IP addresses (complex management)
  \end{itemize}
  \subsubsection{Requirements of apps}
  \begin{itemize}
    \item \textbf{Data integrity}: 100\% reliable vs some data loss
    \item \textbf{Timing}: some apps require low delay to be ``effective''
    \item \textbf{Throughput}
    \item \textbf{Security}
  \end{itemize}
  \subsubsection{Definition of App-layer Protocols}
  \begin{itemize}
    \item \textbf{Types of Messages exchanged,} e.g. request, response
    \item \textbf{Message syntax}, e.g. message fields and how they are delineated
    \item \textbf{Message semantics}: meaning of information in fields
    \item \textbf{Rules} for when and how application send and respond to messages
  \end{itemize}
  \subsubsection{Transport-Layer Protocols}
  \begin{tabularx}{\columnwidth}{|X|X|}
    \hline
    \textbf{TCP}                                                              & \textbf{UDP}                                                      \\
    \hline
    \textbf{Reliable} data transfer                                           & \textbf{Unreliable} data transfer                                 \\
    \hline
    \textbf{Flow control}: sender won't overwhelm receiver                    & \textbf{No flow control}                                          \\
    \hline
    \textbf{Congestion control}: throttle sender when network is overloaded   & \textbf{No congestion control}                                    \\
    \hline
    \textbf{Does not provide}: timing, minimum throughput guarantee, security & \textbf{Does not provide}: timing, throughput guarantee, security \\
    \hline
  \end{tabularx}

  \subsection{Web and HTTP}
  \subsubsection{HTTP}
  \begin{itemize}
    \item HyperText Transfer Protocol
    \item Client/server model
    \item RFC 1945 (HTTP 1.0), RFC 2616 (HTTP 1.1)
    \item Over TCP
  \end{itemize}
  \subsubsection{Persistent HTTP}
  \begin{itemize}
    \item Multiple objects can be sent over single TCP connection
    \item \textbf{Persistent with pipelining}: client may send requests as soon as it encounters a referenced object -- as little as 1RTT for all referenced objects.
  \end{itemize}
  \subsubsection{Non-Persistent HTTP}
  \begin{itemize}
    \item At most 1 object sent over a TCP connection
    \item Requires 2 RTTs per object
    \item Response time $= 2\times RTT + $ file transmission time
  \end{itemize}
  Refer to slides for the rest of HTTP

  \subsection{DNS}
  \begin{itemize}
    \item \textbf{Distributed, Hierarchical Database}
    \item \textbf{Root Server}: answers requests for records in the root zone by returning a list of the authoritative name servers for the appropriate TLD
    \item \textbf{DNS Caching}: based on TTL
    \item Runs over \textbf{UDP}
  \end{itemize}
  \subsubsection{Resource Records (RR)}
  Stores mapping between hostnames and IP addresses, 4-tuple \texttt{(name, value, type, ttl)}
  \begin{itemize}
    \item type = A, \texttt{name} is hostname, \texttt{value} is IP address
    \item type = NS, \texttt{name} is domain, \texttt{value} is hostname of authoritative name server for the domain
    \item type = CNAME, \texttt{name} is alias for some canonical name, \texttt{value} is the canonical name
    \item type = MX, \texttt{value} is the name of mail server assoc with \texttt{name}
  \end{itemize}
  \subsubsection{DNS Name Resolution}
  \begin{itemize}
    \item \textbf{Iterative query}: Local DNS server makes DNS requests one by one in the hierarchy
    \item \textbf{Recursive query} (rarely used): each server in the hierarchy asks one server higher in the hierarchy
  \end{itemize}

  \subsection{Socket Programming}
  \begin{itemize}
    \item \textbf{IP address} is used to identify a host device
    \item \textbf{Process}: program running within a host, identified by \texttt{(IP address :: uint32, port number :: uint16)}
    \item \textbf{Socket}: the software interface between app processes and transport layer protocols
  \end{itemize}
  \subsubsection{UDP}
  \begin{itemize}
    \item No ``connection'' between client and server.
    \item Sender explicitly attaches destination IP address and port number to each packet
    \item Receiver extracts sender IP address and port number from the received packet
  \end{itemize}
  \subsubsection{TCP}
  \begin{itemize}
    \item When client creates socket, client TCP establishes a copnnection to server TCP.
    \item When contacted by client, server TCP creates a new socket for server process to communicate with that client
    \item Allows server to talk with multiple clients individually.
    \item Communicates as if there is a pipe between 2 processes, sending process doesn't need to attach a destination IP address and port number in each sending attempt.
  \end{itemize}

  \section{Transport Layer}
  \subsection{Transport-layer Services}
  \begin{itemize}
    \item Sender: Breaks app messages into \textbf{segments}, passes them to network layer
    \item Receiver: Reassembles segments into message, passes it to app layer
    \item Packet switches in between: only check destination IP address to decide routing
    \item Each IP datagram contains source and dest IP addresses
  \end{itemize}
  \subsection{Connectionless Transport: UDP}
  \begin{itemize}
    \item UDP addes very little on top of IP
          \begin{itemize}
            \item Multiplexing at sender
            \item Demultiplexing at receiver
            \item Checksum
          \end{itemize}
    \item UDP transmission is unreliable, often used by (loss tolerant \& rate sensitive apps)
  \end{itemize}
  \subsubsection{Connectionless De-multiplexing}
  When UDP receiver receives a UDP segment:
  \begin{itemize}
    \item Check destination port number in segment, and direct that segment to the socket with that port number.
  \end{itemize}
  \subsubsection{UDP Header}
  16 bits each for: source port number, dest port number, length, checksum
  \subsubsection{UDP Checksum}
  \begin{itemize}
    \item Treat segment as sequence of 16-bit integers
    \item Apply binary addition, wraparound carry added to the result
    \item Compute 1's complement to get the checksum
  \end{itemize}
  \subsection{Principles of Reliable Data Transport}
  Refer to slides for rdt example protocols
  \subsection{Connection-oriented Transport: TCP}
  \begin{itemize}
    \item \textbf{Point-to-point}: 1 sender, 1 receiver
    \item \textbf{Connection-oriented}: handshake before sending app data
    \item \textbf{Full duplex service}: bi-directional data flow in the same connection
    \item \textbf{Reliable, in-order byte stream}: sequence numbers to label bytes
  \end{itemize}
  \subsubsection{Connection-oriented de-mux}
  A TCP connection/socket is identified by 4-tuple \texttt{(srcIPAddr, srcPort, destIPAddr, destPort)}
  \subsubsection{TCP: buffers and Segments}
  \begin{itemize}
    \item two buffers, send and receive, are created after handshaking at both sides
    \item \textbf{Max Segment Size (MSS)}: typically 1460 bytes, max app-layer data one TCP segment can carry.
  \end{itemize}
  \subsubsection{TCP Header}
  \begin{verbatim}
|1             16            32|
| sourcePort#      destPort#   |
|       sequence number        |
|    acknowledgement number    |
|                              |
|  checksum    |               |
  \end{verbatim}
  \begin{itemize}
    \item \textbf{Sequence Number}: byte number of the first byte of data in a segment
    \item \textbf{ACK number}: sequence number of the next byte of data expected by the receiver
    \item \textbf{Cumulative ACK}: TCP ACKs up to the first missing byte in the tream
  \end{itemize}
  \subsubsection{TCP ACK Generation, Timeout Value, Fast Retransmission}
  Refer to Lecture 4,5 Slide 66

  \section{Network Layer}
  \subsection{DHCP (Dynamic Host Configuration Protocol)}
  4-step process (yiaddr = your internet address):
  \begin{itemize}
    \item Host broadcasts \textbf{DHCP discover} message (src 0.0.0.0:68, dest 255.255.255.255:67, yiaddr 0.0.0.0, txn ID)
    \item DHCP server responds with \textbf{DHCP offer} message (src DHCP.IP:67, dest 255.255.255.255:68, yiaddr, txn ID)
    \item Host requests IP address: \textbf{DHCP request} message (src 0.0.0.0:68, dest 255.255.255.255:67, yiaddr, txn ID)
    \item DHCP server sends address: \textbf{DHCP ACK} message (src DHCP.IP:67, dest 255.255.255.255:68, yiaddr, txn ID)
  \end{itemize}
  DHCP server at UDP port 67, client at UDP port 68
  \subsection{Special IP Addresses}
  \begin{tabularx}{\columnwidth}{X|X}
    \textbf{Special Addresses}                & \textbf{Present Use}                                                                                                                                 \\
    \hline
    0.0.0.0/8                                 & Non-routable meta-address for special use                                                                                                            \\
    \hline
    127.0.0.0/8                               & Loopback address. A datagram sent to an address within this block loops back inside the host. This is ordinarily implemented using only 127.0.0.1/32 \\
    \hline
    10.0.0.0/8, 172.16.0.0/12, 192.168.0.0/16 & Private addresses, can be used without any coordination with IANA or an Internet registry.                                                           \\
    \hline
    255.255.255.255/32                        & Broadcast address. All hosts on the same subnet receive a datagram with such a destination address.
  \end{tabularx}
  \subsection{CIDR}
  \begin{itemize}
    \item Address format: \textbf{a.b.c.d/x} (x = no of bits in subnet prefix)
    \item number of IP addresses = $2^{(32 - x)}$
    \item \textbf{Longest prefix match} for matching on forwarding table
  \end{itemize}
  \subsection{Routing Algorithms}
  \subsubsection{Distance Vector Algorithms}
  \begin{itemize}
    \item Routers know neighbours \& link costs to them
    \item Routers exchange local views with neighbours \& update own local views iteratively to fixed pt.
    \item Use Bellman-Ford: $d_x(y) = min_v\{c(x, v) + d_v(y)\}$
  \end{itemize}
  \subsubsection{RIP (Routing Information Protocol) -- DV algo}
  \begin{itemize}
    \item Hop count as cost metric (insensitive to network congestion)
    \item Entries in the routing table are aggregated subnet masks (routing to destination subnet)
    \item Exchange routing table every 30 seconds over UDP port 520.
    \item \textbf{Self-repair}: if no update from a neighbour router for 3 mins, assume neighbour has failed.
  \end{itemize}

  \subsection{NAT (Network Address Translation)}
  \subsubsection{Implementation}
  \begin{itemize}
    \item Replace (source IP address, port \#) of every \textbf{outgoing datagram} to (NAT IP address, new port \#)
    \item Store in NAT translation table the mapping from (source IP address, port \#) to (NAT IP addressj, new port \#)
    \item Replace (NAT IP, new port \#) in destination fields of every \textbf{incoming datagram} with (source IP, port \#) from NAT translation table.
  \end{itemize}

  \subsection{The Internet Protocol (IP): IPv4}
  \begin{itemize}
    \item Header: 20 bytes (details in L6-7: 45)
    \item Different links may have different MTU (Max Transfer Unit): max amount of data a link-level frame can carry.
    \item Too large IP datagrams may be fragmented by routers, reassembled by destination host: same ID, different offsets, until fragmentation flag is 0
    \item Offset is expressed in unit of 8-bytes.
  \end{itemize}

  \subsection{ICMP (Internet Control Message Protocol)}
  Carried by IP datagrams for error reporting + echo request/reply
  \begin{tabular}{l|l|l}
    \textbf{Type} & \textbf{Code} & \textbf{Description}  \\
    \hline
    8             & 0             & echo request (ping)   \\ \hline
    0             & 0             & echo reply (ping)     \\ \hline
    3             & 1             & dest host unreachable \\ \hline
    3             & 3             & dest port unreachable \\ \hline
    11            & 0             & TTL expired           \\ \hline
    12            & 0             & bad IP header         \\ \hline
  \end{tabular}

  \section{Link Layer}
  Sends datagram between \textbf{adjacent nodes} over a single link.

  Possible services:
  \begin{itemize}
    \item \textbf{Framing}: encapsulating into a frame adding header \& trailer.
    \item \textbf{Link access control}: coordination when multiple nodes share a single link
    \item \textbf{Reliable delivery}: used often on error-prone links (e.g. wireless)
    \item \textbf{Error detection}: caused by signal attenuation/noise -- receiver detects error \& asks sender for retransmission or drops frame
    \item \textbf{Error correction}: corrects bit error(s) without retransmission
  \end{itemize}

  \subsection{Error Detection and Correction}
  \subsubsection{Parity Checks}
  \begin{itemize}
    \item \textbf{Single-bit parity}: can detect single bit errors in data ($d$ data bits with 1 parity bit)
    \item \textbf{2D bit parity}: can detect and correct single bit errors in data, can detect any 2-bit error in data (parity bits for each column, each row, and 1 parity bit for the columns and rows)
  \end{itemize}
  \subsubsection{Cyclic Redundancy Check (CRC)}
  $D$: data bits, $G$: generator or $r + 1$ bits, $R$: will generate CRC of $r$ bits
  \begin{itemize}
    \item long-division by bit-wise XOR operation without carry or borrow
  \end{itemize}

  \subsection{Multiple Access Links and Protocols}
  \subsubsection{Channel Partitioning Protocols}
  \begin{itemize}
    \item \textbf{TDMA} (time-division multiple access): each node gets a fixed length slot, unused slots go idle.
    \item \textbf{FDMA} (frequency-division multiple access): channel spectrum divided into frequency bands, each node assigned a fixed frequency band.
  \end{itemize}
  \subsubsection{Taking-Turns Protocols}
  \begin{itemize}
    \item \textbf{Polling}: master node invites slave nodes to transmit in turn (concerns: polling overhead, single point of failure -- master node)
    \item \textbf{Token passing}: control token passed from a node to next sequentially (concerns: token overhead, single point of failure -- token)
  \end{itemize}
  \subsubsection{Random Access Protocols}
  \begin{itemize}
    \item \textbf{Slotted ALOHA}
          \begin{itemize}
            \item Assumptions: all frames are of equal size, time divided into slots of equal length, nodes transmit only at the beginning of a slot.
            \item Listens to the channel while transmitting (channel detection)
            \item On collision: node retransmits a frame in each subsequent slot with probability $p$ until success
          \end{itemize}
    \item \textbf{Pure ALOHA}: no slot, no synchronization (increased chance of collision)
    \item \textbf{Carrier Sense Multiple Access}
          \begin{itemize}
            \item Sense the channel before transmission
            \item Collisions can still occur due to propagation delay
          \end{itemize}
    \item \textbf{CSMA/CD} (carrier sensing \& deferral)
          \begin{itemize}
            \item When collision is detected, transmission is aborted
            \item Retransmit after a random amount of time
            \item Minimum frame size to prevent undetected collisions
          \end{itemize}

    \item \textbf{CSMA/CA} (collision avoidance): receiver needs to return ACK if a frame is received OK (due to hidden node problem)
  \end{itemize}

  \subsection{Switched Local Area Networks}
  \subsubsection{Link Layer Addressing}
  \begin{itemize}
    \item Every adapter (NIC) has a MAC address, 48 bits long
    \item On receiving a frame, NIC checks if destination MAC address matches its own address. If yes, extracts datagram and passes to protocol stack. Otherwise, discards the frame.
  \end{itemize}
  \subsubsection{ARP (Address Resolution Protocol)}
  \begin{itemize}
    \item Each IP node has an ARP table: stores (IP address, MAC address, TTL) of other nodes in the same subnet
    \item Sending frame:
          \begin{itemize}
            \item \textbf{In the same subnet}:
                  \begin{itemize}
                    \item \textbf{Dest IP in ARP table}: create a frame with dest MAC address from ARP table.
                    \item \textbf{Otherwise}: broadcasts an ARP query packet containing dest IP addr (Dest MAC set to FF-FF-FF-FF-FF-FF), receive MAC addr, store to ARP table, then create a frame with dest MAC address.
                  \end{itemize}
            \item \textbf{To another subnet}: Create a frame with router's MAC address and actual dest IP address. Router then move datagram to outgoing link, constructing a new frame with dest MAC address.
          \end{itemize}
  \end{itemize}
  \subsubsection{Ethernet}
  \begin{itemize}
    \item Topology:
          \begin{itemize}
            \item \textbf{Bus} (popular in mid 90s): all nodes can collide with each other
            \item \textbf{Star} (prevails today): switch in the center, nodes don't collide with each other.
          \end{itemize}
    \item Ethernet header:
          \begin{itemize}
            \item Preamble (8 bytes): 7 bytes 10101010 and 1 byte 10101011
            \item 6 bytes dest addr
            \item 6 bytes src addr
            \item 2 bytes type (indicating higher level protocol, mostly IP)
          \end{itemize}
    \item Ethernet trailer: 4 bytes CRC-32
    \item Service:
          \begin{itemize}
            \item \textbf{Connectionless}: no handshaking
            \item \textbf{Unreliable}: no ACK or NAK
            \item \textbf{Multiple Access}: CSMA/CD with binary exponential backoff
          \end{itemize}
    \item Ethernet CSMA/CD:
          \begin{itemize}
            \item On collision, abort, send jam signal
            \item Then, binary backoff: after $m$-th collision, choose random $K$ from $\{0, 1, 2, ..., 2^m - 1\}$
            \item NIC waits $K \times 512$ bit times before retransmitting
          \end{itemize}
  \end{itemize}

  \subsection{Link-layer Switches}
  \begin{itemize}
    \item Star topology: hosts have dedicated connection to switch.
    \item Switch buffer frames and is full-duplex
    \item \textbf{Switch Forwarding Table}: list of (MAC addr, interface, TTL)
    \item \textbf{Self-learning}: switch learns which hosts can be reached through which interfaces:
          \begin{itemize}
            \item On receiving frame, note down (MAC addr, interface, TTL) of src in forwarding table
            \item If dest is found on the table, forward frame to that link.
            \item Otherwise, broadcast the frame to all outgoing links.
          \end{itemize}
    \item Routers vs Switches:
          \begin{itemize}
            \item \underline{Routers} check \textbf{IP address}, \underline{Switches} check \textbf{MAC address}
            \item Both \textbf{store-and-forward}
            \item \underline{Routers} \textbf{compute routes} to destination, \underline{Switches} \textbf{forward frame} to outgoing link or broadcast
          \end{itemize}
  \end{itemize}

  \section{Multimedia Networking}
  \subsection{Streaming stored Video}
  \begin{itemize}
    \item Client-side buffering and playout delay to compensate for network-added delay, delay jitter
    \item \textbf{Push-based streaming}: via UDP, transmission rate can be oblivious to congestion levels
    \item \textbf{Pull-based streaming}: via HTTP GET at max possible rate under TCP, fill rate fluctuates due to TCP congestion control, retransmissions
  \end{itemize}
  \subsection{Voice-over-IP}
  Application sends segment into socket every 20 ms during talkspurt
  \subsubsection{Losses}
  \begin{itemize}
    \item \textbf{Network loss}: IP datagram lost due to network congestion (router buffer overflow)
    \item \textbf{Delay loss}: datagram arrives too late for playout (max tolerable delay: 400 ms)
    \item \textbf{Loss tolerance}: depends on voice encoding, loss concealment, 1-10\% can be tolerated
  \end{itemize}
  \subsubsection{Dealing with Jitter}
  \begin{itemize}
    \item \textbf{Fixed playout delay}
    \item \textbf{Adaptive playout delay}
          \begin{itemize}
            \item Estimate network delay, adjust playout delay at beginning of each talk spurt.
            \item Silent periods compressed and elongated
            \item $d_i = (1 - \alpha)d_{i - 1} + \alpha(r_i - t_i)$ where $\alpha$ is a small constant, e.g. $0.1$
            \item Estimate avg deviation of delay $v_i = (1 - \beta) v_{i - 1} + \beta \abs{r_i - t_i - d_i}$
            \item For first packet in talk spurt, $\text{playout-time}_i = t_i + d_i + Kv_i$
          \end{itemize}
  \end{itemize}
  \subsubsection{Recovery from packet loss}
  Each ACK/NAk takes 1 RTT, alternative is FEC (Forward Error Correction):
  \begin{itemize}
    \item \textbf{Simple FEC}: for every group of $n$ chunks, create redundant chunk by XOR-ing $n$ original chunks (increase bandwidth by $\frac1n$, reconstruct at most 1 lost chunk from $n + 1$ chunks)
    \item \textbf{Piggyback lower quality stream FEC}: send lower resolution audio stream as redundant information (non-consecutive loss: receiver can conceal loss)
    \item \textbf{Interleaving} to conceal loss, packet contains small units from differnet chunks.
  \end{itemize}
  \subsection{Protocols for Real-Time Conversational Applications}
  \subsubsection{RTP (Real-time Protocol)}
  \begin{itemize}
    \item \textbf{RTP} for media flow (via UDP usually)
    \item \texttt{RTCP} (real-time control protocol) for out-of-band statistics and control information for an RTP session (via UDP usually)
    \item \textbf{RTSP} (real-time streaming protocol), e.g. Play, Pause (via TCP usually)
    \item Runs on UDP, details on headers on L10:43
    \item Advantage: Short end-to-end latency ($<100-500$ms)
    \item Disadvantages:
          \begin{itemize}
            \item Special-purpose server for media, keep state (complex)
            \item Protocol use TCP and UDP transmissions (firewalls)
            \item Difficult to cache data (no web caching)
          \end{itemize}
  \end{itemize}
  \subsubsection{SIP (Session Initiation Protocol)}
  \begin{itemize}
    \item Mechanism for call setup:
          \begin{itemize}
            \item For caller to let callee know the former wants to establish a call
            \item Caller and calee can agree on media type, encoding
            \item End call
          \end{itemize}
    \item Determine current IP address of callee (similar to DNS)
    \item Call management (add new media streams, change encoding during call; invite others; transfer, hold calls)
  \end{itemize}
  \subsection{DASH (Dynamic Adaptive Streaming over HTTP)}
  \begin{itemize}
    \item Use HTTP protocol to stream media; divide media into small chunks.
    \item More info on L10:54-57
    \item Advantages:
          \begin{itemize}
            \item Server is simple (no state)
            \item No firewall problem
            \item Standard web caching works
          \end{itemize}
    \item Disadvantages:
          \begin{itemize}
            \item Based on media segment transmissions, typically 2-10s long
            \item By buffering on client side, DASH doesn't provide low latency for interactive, two-way app.
          \end{itemize}
  \end{itemize}

  \section{Network Security}
  Read lecture notes

  \section{Physical Layer}
  \subsection{Digital Transmission}
  \subsubsection{NRZ (Non Return to Zero)}
  \begin{itemize}
    \item \textbf{NRZ-L}: absolute voltage level (high = 0, low = 1)
    \item \textbf{NRV-I}: inverts if bit 1 is encountered
  \end{itemize}
  \subsubsection{RZ (Return to Zero)}
  3 voltage levels, return to zero halfway through a bit interval, (high = 1, low = 0)
  \subsubsection{Manchester}
  Inverts signal in the midle of the bit, ($- \to +$ = 1, $+ \to -$ = 0)
  \subsection{Analog transmission}
  \begin{itemize}
    \item $A\sin(2\pi ft+\phi)$ where $A$ = peak amplitude, $f$ = frequency, $\phi$ = phase.
    \item \textbf{Channel bandwidth} = frequency range ($f_{hi} - f_{lo}$)
    \item \textbf{SNR (Signal to Noise Ratio)} = strength of signal over noise
  \end{itemize}
  \subsubsection{Shannon Channel Capacity}
  \begin{itemize}
    \item Theoretical max bit rate of a noisy channel
    \item $C = B \times \log_2(1 + SNR)$ where $C$ = bit-rate, $B$ = channel bandwidth
  \end{itemize}
  \subsubsection{Analog encoding}
  Changing $A$, $f$, or $\phi$.
  \begin{itemize}
    \item \textbf{ASK (Amplitude Shift Keying)}: change $A$ to represent 0 and 1, susceptible to noise.
    \item \textbf{FSK (Frequency Shift Keying)}: change $f$ to represent 0 and 1, limited by channel bandwidth.
    \item \textbf{PSK (Phase Shift Keying)}: change $\phi$ to represent 0 and 1
    \item \textbf{QPSK (Quadrature PSK)}: signal with 4 possible phases for 2 bits data for every signal
    \item \textbf{8-PSK}: 8 possible phases for 3 bits of data for every signal
    \item \textbf{$2^k$-QAM (Quadrature Amplitude Modulation)}:
          \begin{itemize}
            \item A \textbf{signal unit} is a combination of amplitude and phase that represents $k$ bits.
            \item \textbf{Baud rate} = no of signal units per second.
            \item \textbf{Bit rate} = no of bits receiver receives / second
            \item Combines ASK and PSK, check both amplitude and phase to determine data carried.
          \end{itemize}
  \end{itemize}
  \subsubsection{Examples}
  \begin{itemize}
    \item Ethernet, RFID, NFC = Manchester
    \item USB = NRZ-I
    \item Digital RV uses DVB-T = QPSK, 16-QAM, 64-QAM
    \item Wi-Fi = PSK, QPSK, 16-QAM, 64-QAM
  \end{itemize}

\end{multicols*}
\end{document}
